(* ::Package:: *)

(* ::Input:: *)
(*(* :Title: Matrix *)*)
(*(* :Context: matrix_pacchetto` *)*)
(*(* :Author: Martina Daghia, Martina Zauli, Riccardo Spini, Gabriele Fogu *)*)
(*(* :Summary: Spiegazione prodotto tra matrici a scopo didattico *)*)
(*(* :Copyright: Matrix 2023 *)*)
(*(* :Package Version: 22, Maggio 2023 *)*)
(*(* :Mathematica Version: 13.2.1.0 *)*)
(*(* :Sources: biblio *)*)
(**)
(*BeginPackage["matrix_pacchetto`"];*)
(*prodottoMatrici::usage="prodottoMatrici [] *)
(*	Calcola e ritorna una matrice che rappresenta il prodotto tra due matrici date in input"*)
(**)
(*inputMatrice::usage="inputMatrice [] *)
(*	Permette all'utente di inserire manualmente due matrici scegliendo i valori delle righe e delle colonne e i valori per ogni posizione. *)
(*	Ritorna le due matrici che l'utente ha creato."*)
(**)
(*randomMatrici::usage="randomMatrici[] *)
(*	Ritorna due matrici create randomicamente (con valori da 0 a 10) attrraverso il seed che sceglie l'utente"*)
(**)
(**)
(*(*definisco il pacchetto*)*)
(*BeginPackage["matrix_pacchetto`"]; *)
(**)
(**)
(*(**)
(*non \[EGrave] necessario utilizzare un contesto separato nel pacchetto per il prodotto tra 2 matrici.*)
(*utilizzare un contesto separato \[EGrave] utile per organizzare e isolare il codice in contesti logici distinti --> per il nostro progetto semplice non importa*)
(**)
(*Begin["`Private`"]*)
(**)
(**)*)
(**)
(*(* DIRETTIVE*)
(*	Inserire nella prima coppia di graffe tutte le variabili che usiamo nel codice. TUTTE. Inserire all'interno delle seconde graffe il codice vero e proprio*)
(**)*)
(**)
(*(* di seguito sono elencate le funzioni facenti parte del pacchetto Matrix *)*)
(**)
(*(* FUNZIONE PER PRODOTTO SCALARE TRA 2 MATRICI *)*)
(*prodottoMatrici[A_,B_]:=Module[{m,n,q,p,resultMatrix},*)
(*{m,n}=Dimensions[A];(* restituisce le dimensioni dela matrice come numero righe e numero colonne *)*)
(*{q,p}=Dimensions[B];*)
(*If[m!=p,  (* controllo il numero di riga della matrice A con il numero di colonne della matrice B *)*)
(*	Print["Le dimensioni delle matrici non sono compatibili per il prodotto."];*)
(*	Return[]*)
(*];*)
(*resultMatrix=ConstantArray[0,{m,p}]; (* creo la matrice C con m (numero di righe) e p (numero di colonne), imposto gli elementi a 0 *)*)
(*Do[*)
(*(*resultMatrix[[i,j]]=Sum[A[[i,k]]*B[[k,j]],{k,n}],{i,m},{j,p}]; i da 1 a m, j da 1 a p, k da 1 a n*)*)
(*resultMatrix[[i,j]]=Sum[(Print["Calcolo ", A[[i,k]]," * ",B[[k,j]], " = ", A[[i,k]]*B[[k,j]]];*)
(*A[[i,k]]*B[[k,j]]),{k,n}];*)
(*Print [ "La somma \[EGrave]: ",resultMatrix[[i,j]]],{i,m},{j,p}]; (* stampo anche il risultato da far vedere l'utente*)*)
(**)
(*resultMatrix*)
(*]*)
(**)
(**)
(*(* FUNZIONE PER FAR INSERIRE LE DUE MATRICI ALL'UTENTE *)*)
(*(*NON FUNZIONAAAAAAA CONTROLLARE*)*)
(**)
(*inputMatrici[]:=Module[{nA,mA,nB,mB},nA=Input["Inserisci il numero di righe della prima matrice: "];*)
(*mA=Input["Inserisci il numero di colonne della prima matrice: "];*)
(*nB=Input["Inserisci il numero di righe della seconda matrice: "];*)
(*mB=Input["Inserisci il numero di colonne della seconda matrice: "];*)
(*If[mA!=nB,Print["Errore: Il numero di righe della prima matrice deve essere uguale al numero di colonne della seconda matrice."];*)
(*Return[]];*)
(*Print["Dimensioni delle matrici corrette. Inserisci gli elementi della prima matrice:"];*)
(*matriceA=inputMatrice["A",nA,mA];*)
(*Print["Inserisci gli elementi della seconda matrice:"];*)
(*matriceB=inputMatrice["B",nB,mB];*)
(*{matriceA,matriceB}]*)
(**)
(*inputMatrice[name_,n_,m_]:=Module[{messaggio,valore,matrice},Print["Creazione della matrice "<>name<>" (dimensioni: "<>ToString[n]<>"x"<>ToString[m]<>")"];*)
(*matrice=ConstantArray[0,{n,m}];*)
(*Do[messaggio="Inserisci il valore per l'elemento ("<>ToString[i]<>","<>ToString[j]<>"): ";*)
(*valore=Input[messaggio];*)
(*While[!NumericQ[valore],Print["Errore: Inserisci un valore numerico."];*)
(*valore=Input[messaggio];];*)
(*matrice[[i,j]]=valore;,{i,n},{j,m}];*)
(*matrice;*)
(*Print["Matrice "<>name<>" creata."];*)
(*Print[matrice];*)
(*Return[matrice]]*)
(* *)
(*(* FUNZIONE CHE GENERA DUE MATRICI RANDOMICHE CON IL SEED DATO IN INPUT DALL'UTENTE*)*)
(*randomMatrici[n_,m_] :=Module[{seed,matriceA,matriceB},*)
(**)
(*n = "Inserisci il numero di righe delle matrice "<>name <> ": " ;*)
(*m = "Inserisci il numero di colonne della matrice "<>name <> ": " ;*)
(**)
(*While[!NumericQ[n],*)
(*	Print["Errore: Inserisci un valore numerico."];*)
(*			n=Input[inserimentoRighe];*)
(*	];*)
(*	While[!NumericQ[m],*)
(*	Print["Errore: Inserisci un valore numerico."];*)
(*		m=Input[inserimentoColonne];*)
(*	];*)
(**)
(*	Print["Numero di righe della matrice "<>name <> " che hai inserito: ", n];*)
(*	Print["Numero di colonne della matrice "<>name <> " che hai inserito: ",m];*)
(*	*)
(*seed=Input["Inserisci il valore del seed: "];*)
(*seed=StringReplace[ToString[seed],","->"."];*)
(*While[!NumericQ[seed],Print["Errore: Inserisci un valore numerico."];*)
(*seed=Input["Inserisci il valore del seed: "];*)
(*seed=StringReplace[ToString[seed],","->"."];];*)
(**)
(*SeedRandom[seed];*)
(*Print["Il seed \[EGrave]: "];*)
(*Print[seed];*)
(**)
(*matriceA=RandomInteger[{0,10},{n,m}];*)
(*matriceB=RandomInteger[{0,10},{n,m}];*)
(**)
(*Print["Matrice randomica A: "];*)
(*Print[matriceA];*)
(*Print["Stampa griglia della matrice A: "];*)
(*Grid[matriceA,Frame->All];*)
(**)
(*Print["Matrice randomica B: "];*)
(*Print[matriceB];*)
(*Print["Stampa griglia della matrice B: "];*)
(*Grid[matriceB,Frame->All];*)
(**)
(*{matriceA,matriceB}*)
(**)
(*]*)
(**)
(*(**)
(*{n,m}={4,4};*)
(*{matrix1,matrix2}=randomMatrici[n,m];*)
(*Grid[matrix1,Frame->All];*)
(*Grid[matrix2,Frame->All];*)
(*result=prodottoMatrici[matrix1,matrix2];*)
(*	Print[result];*)
(*Grid[{{Grid[matrix1,Frame->All],"x",Grid[matrix2,Frame->All], "=", Grid[result,Frame->All]}}]*)
(**)
(**)*)
(**)
(*(**)
(*End[]*)
(**)*)
(*EndPackage[]*)
(**)
(**)
(**)
(**)


4











?C





